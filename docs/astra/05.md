---
sidebar_position: 5
---

# Репликация Postgres

## Как работает репликация без слота
Без слота репликации:
- Мастер отправляет WAL сегменты по запросу реплики (по протоколу streaming replication).
- Мастер **не отслеживает**, какие сегменты уже получены репликой.
- WAL файлы удаляются по расписанию (настройка `wal_keep_size`, `max_wal_size` или архивация).
## Почему слоты рекомендуются

Репликационный слот (**replication slot**) решает ключевые проблемы:
- Мастер **гарантированно хранит** WAL сегменты, пока реплика их не получит.
- Автоматическое управление жизненным циклом WAL.
- Защита от потери данных при временных отключениях реплики.

## Как создать слот (кратко)
На мастере:
```sql
SELECT pg_create_physical_replication_slot('slot1');
```
На реплике в `postgresql.auto.conf`:
```ini
primary_slot_name = 'slot1'
```

Состояние репликации на мастере
```sql
select * from pg_stat_replication;
```
Список слотов репликации на мастере
```sql
SELECT slot_name, slot_type, active FROM pg_replication_slots;
```
Состояние репликации на слейве
```sql
select * from pg_stat_wal_receiver;
```
### Мастер
создаем пользователя для репликации
```sql
CREATE ROLE repluser WITH LOGIN REPLICATION password 'postgres';
```
в pg_hba.conf разрешаем подключение типа replication с нужных IP - например так 
```
host    replication     all             192.168.5.0/24         md5
```
в postgresql конфиге настраиваем репликацию
```ini
listen_addresses ='*'

wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
hot_standby = on
hot_standby_feedback = on
```
- _**wal_level** указывает, сколько информации записывается в WAL (журнал операций, который используется для репликации);_ 
- _**max_wal_senders** — количество планируемых слейвов;_ 
- _**max_replication_slots** — максимальное число слотов репликации  
- _**hot_standby** — определяет, можно или нет подключаться к postgresql для выполнения запросов в процессе восстановления;_ 
- _**hot_standby_feedback** — определяет, будет или нет сервер slave сообщать мастеру о запросах, которые он выполняет._

**Перезапускаем службу postgresql  на мастере** чтобы применились новые настройки (если они уже применены - не перезапускаем. Посмотреть какие параметры у сервера сейчас можно в psql при помощи команд вида `SHOW wal_lever;` `SHOW host_standby;`  и т.д).
Далее на master можно создать слот репликации который будет использован на slave
Например создадим слот репликации с именем slot1
```sql
SELECT pg_create_physical_replication_slot('slot1');
```

### Slave
Подготовка сервера
1. останавливаем службу postgresql
2. очищаем каталог кластера **/var/lib/pgpro/1c-16/data** (можно переименовать каталог кластера), pg_basebackup при создании реплики кластера сам пытается создать каталог указанный в параметре `--pgdata`
3. делаем первичную инициализацию с указанием слота репликации если мы его создали заранее на `master` сервере postgresql, если слот репликации не делали то не указываем параметр `--slot`.  В `--pgdata` указываем путь для каталога кластера PostgreSQL 

* на Астре зайти в 0 сессию;
```bash
sudo -s
su - postgres

pg_basebackup --host=192.168.5.146 --username=repluser --pgdata=/var/lib/pgpro/1c-16/data --wal-method=stream --write-recovery-conf --slot=slot1
```
Вводим пароль **postgres** пользователя repluser которого создали на мастере. Чтобы не вводить логин/пароль от пользователя репликации можно записать его в файле `.pgpass` для пользователя postgres.
После инициализации создается конфиг репликации в каталоге указанном в ---pgdate (например в /var/lib/pgpro/1c-16/data/postgresql.auto.conf)
```ini
# Do not edit this file manually!
# It will be overwritten by the ALTER SYSTEM command.
primary_conninfo = 'user=repluser password=postgres channel_binding=prefer host=192.168.5.146 port=5432 sslmode=prefer sslcompression=0 sslsni=1 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres target_session_attrs=any'
primary_slot_name = 'slot1'
```

Запускаем postgresql на слейве. Служба может не запуститься если конфиг postgres на slave отличается от master по количеству worker  - У меня на тесте выдало такое
```bash
Параметр max_worker_processes = 4 меньше, чем на ведущем сервере, где его значение было 6.
```
